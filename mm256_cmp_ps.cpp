/*
  This file is a simple test of the AVX instruction _mm256_cmp_ps.
  trying to find a replacement of the vpcmpeqd AVX2 instruction
  it seems that
    vcmpps	$0, ...
    vcmpps      $8, ...
  are good candidates, in the header file it is said that 
  8 is non-signaling, maybe it is preferable.


  It also provides a good way to get a register with all bits set
  to zero or one {vcmpps $11, ...}, or {vcmpps $15, ...} respectively

 
  If you want to try it by yourself

       g++ -mavx mm256_cmp_ps_test.cpp -s -o mm256_cmp_ps_test.s
       g++ mm256_cmp_ps_test.s -o mm256_cmp_ps_test
      ./mm256_cmp_ps_test
  
  Where m256_cmp_ps_test.s is the assembly source generated by g++
  and m256_cmp_ps_test is an executable with the tests described
  here.
  
*/

#include <immintrin.h>
#include <cstdio>
#include <stdint.h>
void show(uint32_t* v){
  for(int i = 0; i < 8; ++i){
    printf(" %08x", v[i]);
  }
  printf("\n");
}

int main(){
  __m256 mv0 = {-2.f,-1.f,0.f,1.f,2.f,3.f,4.f,0.f};
  __m256 mv1 = { 6.f, 5.f,4.f,3.f,2.f,1.f,0.f,0.f};
  __m256 mvrand;
  __m256 r;
  FILE *fh = fopen("/dev/urandom", "r"); // Get some random bits
  fread(&mvrand, 1, sizeof(mvrand), fh);
  fclose(fh);
  r = _mm256_cmp_ps(mv0, mv1, 0);
  show((uint32_t*)&r);
  show((uint32_t*)&r);
  r = _mm256_cmp_ps(mv0, mv0, 0);
  show((uint32_t*)&r);
  r = _mm256_cmp_ps(mv0, mv0, 8);
  show((uint32_t*)&r);
  r = _mm256_cmp_ps(mvrand, mv0, 15);
  show((uint32_t*)&r);
  r = _mm256_cmp_ps(mvrand, mv0, 11); // It seems that
  show((uint32_t*)&r);
  r = _mm256_cmp_ps(mv0, mvrand, 8);
  show((uint32_t*)&r);
  return 0;
}
